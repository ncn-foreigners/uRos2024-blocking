---
title: "Zadanie rekrutacyjne (NCN OPUS 20)"
author: "Maciej Beręsewicz"
output:
  html_document:
    df_print: paged
  html_notebook: default
  pdf_document: default
lang: pl
---

# Formalności

Rozwiązania zadania można przesłać w tym lub innym notatniku (np. quarto czy jupyter).

Zadania proszę rozwiązać samodzielnie, nie korzystać z modeli językowych typu ChatGPT, LLamma czy Claude. Tym zadaniem sprawdzam Państwa wiedzę, a nie umiejętność pisania "promptów".

# Zadanie 1 -- teoria

Celem zadania jest wyznaczenie postaci analitycznej wektora wag kalibracyjnych $\textbf{w}$ korzystając z metody mnożników Lagrange'a.

Zadanie składa się z następujących etapów:

1.  Należy zapoznać się z załączonymi slajdami **kalibracja-zadanie.pdf**.
2.  Zadanie znajduje się na slajdzie 9 ("Estymator kalibracyjny wartości globalnej").
3.  Aby je rozwiązać należy skorzystać z mnożników Lagrange'a aby wyznaczyć postać analityczną wektor $\mathbf{w}$ minimalizujący funkcję odległości daną wzorem (16) przy ograniczeniach danych wzorem (17). **Uwaga:** slajd 9 uwzględnia tylko warunki (W1) i (W2) ze slajdu 6. Nie należy uwzględniać warunku (W3) ponieważ wtedy nie uzyska się postaci analitycznej.
4.  Wzór analityczny znajduje się na slajdzie "Twierdzenie o wagach kalibracyjnych" (slajd 10). **Można go wykorzystać celem sprawdzenia poprawności wyników**.

Wynik należy zapisać w języku $\LaTeX$. Rozwiązanie można zapisać korzystając z tego notatnika (jak również Quarto/Jupyter) lub dodać link do projektu na Overleaf czy plik PDF.

## Próba rozwiązania (Daniel Witański):

Dane są następujące równania: 

$$D( \mathbf{w} , \mathbf{d} ) = \frac{1}{2} \sum_{i=1}^{n} \frac{ (w_{i}-d_{i})^2 }{ d_{i} }$$ 

Funkcja $D$ jest minimalizowana względem wektora $\mathbf{w}$ zdefiniowanego jako 

$$\mathbf{w} = (w_{1}, w_{2}, \dots, w_{n})^T$$ 

Przy ograniczeniach zdefiniowanych jako $\mathbf{X} = \mathbf{ \tilde{X} }$, gdzie $\mathbf{ \tilde{X}} = \left( \sum_{i=1}^{n} w_{i}x_{i1}, \sum_{i=1}^{n} w_{i}x_{i2}, \dots, \sum_{i=1}^{n} w_{i}x_{ik} \right)^{T}$, $\mathbf{X} = \left( \sum_{i=1}^{N}x_{i1}, \sum_{i=1}^{N}x_{i2}, \dots, \sum_{i=1}^{N}x_{ik} \right)^T$ 

To ograniczenie oznacza, że suma ważona obliczona za pomocą wag kalibracyjnych będzie równa wartości cechy w populacji dla każdej zmiennej, co jest celem tej metody. Kolejnym krokiem jest przekształcenie powyższego ograniczenia do postaci $\mathbf{ \tilde{X} } - \mathbf{X} = 0$, jest to postać, którą można stosować w metodzie mnożników Lagrange'a.

Lagrangian dany jest następującym równaniem: 

$$L(x_{1}, x_{2}, \dots, x_{n}) = f(x_{1}, x_{2}, \dots, x_{n}) + \sum^{k}_{j=1} \lambda_{j} * g(x_{1}, x_{2}, \dots, x_{n})$$ 

Równanie to w tym przypadku przyjmuje postać: 

$$L(w_{1}, w_{2}, \dots, w_{n}) = \frac{1}{2} \sum_{i=1}^{n} \frac{ (w_{i}-d_{i})^2 }{ d_{i} } + \sum^{k}_{j=1} \lambda_{j} * \left( \sum_{i=1}^{n} w_{i}x_{ij} - \sum_{i=1}^{N} x_{ij} \right)$$

Punkty będące potencjalnymi ekstremami spełniają warunek: 

$L'_{w_{1}} = L'_{w_{2}} = \dots = L'_{w_{n}} = 0$ 

W tym przypadku wszystkie pochodne kierunkowe mają tę samą postać, można więc przedstawić to równanie w postaci: 

$$\frac{1}{2} * \frac{ 2(w_{i} - d_{i}) }{ d_{i} } + \sum_{j=1}^{k} \lambda_{j} * x_{ij} = 0, \text{ gdzie } i = 1, 2, \dots, n$$ Równoważnym zapisem tej funkcji jest zapis: $$\frac{ (w_{i} - d_{i}) }{ d_{i} } = - \sum_{j=1}^{k} \lambda_{j} * x_{ij}$$

~~Do wyznaczenia lambdy wykorzystamy postać macierzową, gdyż sumę~~ 

$\sum_{j=1}^{k} \lambda_{j} * x_{ij}$ ~~można przedstawić jako~~ 
$\mathbf{ \lambda^{T} x_{i} }$ $$\frac{ (w_{i} - d_{i}) }{ d_{i} } = - \mathbf{ \lambda^{T} x_{i} }$$ To nic nie daje, bo macierz $\mathbf{ x_{i} }$ nie jest kwadratowa.

... Wzór po wszystkich przekształceniach wygląda następująco: $$\mathbf{w}_{i} = d_{i} + d_{i} (\mathbf{X} - \mathbf{ \hat{X} })^{T} \left( \sum^{n}_{i=1} d_{i} \mathbf{x}_{i}\mathbf{x}_{i}^{T} \right)^{-1} \mathbf{x}_{i}$$

# Zadanie 2 -- implementacja

Mając samodzielnie wyprowadzony wzór analityczny z zadania 1 lub (gdyby się nie udało) wzór ze slajdu 10 należy zaimplementować go w dowolnym języku programowania by rozwiazać poniższe zadanie.

Zadanie składa się z następujących etapów:

1.  Należy zapoznać się z zadaniem ze slajdu 11 i 12.
2.  Zbiór znajduje się w załączonym pliku csv **przyklad.csv**, a opis zbajduje się na slajdzie 13 ("Sztuczny zbiór danych").
3.  W przypadku zmiennej jakościowej określającej wielkość podmiotu należy utworzyć zmienne 0-1 (tzn. dummy variables, one-hot encoding), a do obliczeń wybrać tylko jeden z poziomów (M lub L) aby uniknąć wspóliniowości. Kalibracja powinna odtwarzać liczbę:
    -   liczbę podmiotów $N=1000$,
    -   sumę przychodów równą 19,000,
    -   oraz liczbę podmiotów (średnich=720 lub duzych=180)
4.  Wynik podany jest na slajdzie 14 (pozwoli zweryfikować poprawność obliczeń).

**UWAGA:** Można wysłać również rozwiąania niekompletne lub dające błędne wyniki co będzie podstawą rozmów.

## Implementacja (Daniel Witański)

```{R - Implementacja}
# Zaczynamy poprzez przygotowanie danych- załadowanie danych z pliku i stworzenie macierzy
data <- read.csv('przyklad.csv', sep = ';')
data1 <- data.frame(data[,2], 
                    ifelse(data[,3] == 'L', 1, 0), 
                    ifelse(data[,3] == 'M', 1, 0))
                    colnames(data1) <- c('przychod', 'czy_duze', 'czy_srednie')

# Przygotowujemy też inne wartości niezbędne do analizy
pop_values <- c(19000, 280, 720)
pop_size <- 1000
weight <- data[,4]

calibratingWeights <- function(x, 
                               pop_x, 
                               pop_size, 
                               weight=rep(pop_size/nrow(x), length.out = nrow(x)), 
                               full_output=NULL) {

  # if ( nrow(x) != length(weight) ) {
  #  warning('Macierz obserwacji w próbie i wektor wag mają różną liczbę wierszy.')
  # }

  # if ( ncol(x) != length(pop_x) ) {
  #   warning('Liczba kolumn w macierzy obserwacji w próbie jest różna od liczby podanych wartości w populacji.')
  # }
  # Chyba nie jest potrzebne, gdyż R sam z siebie sypie błędami w takim przypadku
  
  # Konwersja obiektu na macierz- długość obiektu
  # jest często wykorzystywana później. Macierz jest też transponowana
  x <- as.matrix(x)
  
  # Obliczenie (sumy ważonej) x_hat używanego w obliczeniach
  x_hat <- vector(length = ncol(x))
  for (j in c(1:ncol(x))) {
    x_hat[j] <- sum(x[,j] * weight)
  }
  
  # Obliczanie odwrotności (przedostatnia część wzoru)
  inverse_matrix <- matrix(data = 0, ncol = ncol(x), nrow = ncol(x))
  for (i in c(1:nrow(x))) {
    inverse_matrix <- (x[i,] %*% t(x[i,]) * weight[i]) + inverse_matrix
  }
  inverse_matrix <- solve(inverse_matrix)
  
  # Obliczanie wektora wag kalibracyjnych
  cal_weights <- vector(length = nrow(x))
  for(i in c(1:nrow(x))) {
    cal_weights[i] <- weight[i] + (weight[i] * (pop_x - x_hat) %*% inverse_matrix %*% x[i, ])
  }
  
  if (is.null(full_output) == T) {
    return(cal_weights)
  }
  return(list(macierz_próby = x, wartości_w_populacji = pop_x, rozmiar_populacji = pop_size, wagi = weight, wagi_po_kalibracji = cal_weights))
}

```

```{R}
wynik <- calibratingWeights(data1, pop_values, pop_size, weight)
wynik
```
